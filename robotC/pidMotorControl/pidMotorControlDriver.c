#ifndef motor_control_driver_c
#define motor_control_driver_c

#ifdef debugPid
#pragma config(Motor,  motorA,          motor1,        tmotorNXT, openLoop, encoder)
#endif // debugPid
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// \cond - tell Doxigen to not include prototypes, typedefs and globals in the generated documentation.

const int maxSavedDataPoints = 20;
/*
 * Internal data Structure used to save motor information
 */
typedef struct
{
  int  currentMotorPower; // current motor power setting
  int  targetMotorSpeed;  // desired motor speed setting in degrees per second
  int  setMotorSpeed;     // speed set by the user
  long savedEncoderValue; // encoder value from past reading
  long timeOfPastEncoderRead;
  int  motorID;           // ID of motor to control
  // error history used in integration and derivative calculation
  int  errorDataPoints[maxSavedDataPoints];
  int  dataPointIndex;
  int  numDataPoints;
} motorObjectType;

// upper speed limit - Note this is hard coded based on the performance of a Lego motor.
const int maxDegSec = 900;

// max number of motors driver can  control
const int maxNumberOfMotors = 10;

// Number of motors the driver that have been initialized so far
static int numberOfMotors = 0;

// number of milliseconds to wait between error calculations
static int motorChangeTimeInterval = 5;

static motorObjectType motors[maxNumberOfMotors];

task serviceMotorPowerChange();

// \endcond

/** ***************************************************************************
 * \brief Initialize PID motor control driver.
 *
 * \param serviceTime - This is how often the PID background thread runs.  The 
 * specified is milliseconds.  The PID background thread will execute as often
 * every X milliseconds as specified by this parameter.
 * The default value is 25 milliseconds.
 */
void initialializePidMotorControl(int serviceTime = 25)
{
  nMotorPIDSpeedCtrl[motorA] = mtrNoReg;
  StartTask(serviceMotorPowerChange);
  motorChangeTimeInterval = serviceTime;
}

/** ***************************************************************************
 * \brief Brings all motors to a halt and stops the motor control task. 
 */
void stopMotorControl()
{

  StopTask(serviceMotorPowerChange);

  for (int motorIndex = 0; motorIndex < numberOfMotors; motorIndex++)
  {
  	motor[motors[motorIndex].motorID] = 0;
  }

}

/** ***************************************************************************
 * \brief Initialize specific motor to be controlled by the driver.
 *
 * When called for the first time for a specific motorID, the current and
 * target power levels are set to zero.  
 *
 * \param motorID - ID of motor to be controlled.
 *
 */
void initializeIndividualMotor(int motorID)
{
	// turn off PID performed by robotC - We will be controlling the motor
  nMotorPIDSpeedCtrl[motorID] = mtrNoReg;

  bool found = false;
  // search to see of motor is already stored in control array
  for (int motorIndex = 0; motorIndex < numberOfMotors; motorIndex++)
  {
    if(motors[motorIndex].motorID == motorID)
    {
      found = true;
    }
  } // for each existing motor in control array

  if (!found && (numberOfMotors < maxNumberOfMotors))
  {
    motors[numberOfMotors].motorID = motorID;
    motors[numberOfMotors].currentMotorPower = 0;
    motors[numberOfMotors].targetMotorSpeed = 0;
    motors[numberOfMotors].setMotorSpeed = 0;
    motors[numberOfMotors].savedEncoderValue = nMotorEncoder[motorID];
    motors[numberOfMotors].timeOfPastEncoderRead = time1[T1];
    motors[numberOfMotors].dataPointIndex = 0;
    motors[numberOfMotors].numDataPoints = 0;
    numberOfMotors++;
  } // if motor needs to be added to array

} // initializeIndividualMotor

/** ***************************************************************************
 * \brief Set the target power level for the specified motor.
 *
 * Important Note: initializeIndividualMotor must be called prior to
 * calling this function with the specific motorID.
 *
 * \param motorID - motor to apply newTargetPowerLevel to.
 *
 * \param newTargetPower - power level to apply to motor.
 */
void setMotorPower(int motorID, int newTargetSpeed)
{
  for (int motorIndex = 0; motorIndex < numberOfMotors; motorIndex++)
  {
    if(motors[motorIndex].motorID == motorID)
    {
      motors[motorIndex].targetMotorSpeed = newTargetSpeed;
      motors[motorIndex].setMotorSpeed    = newTargetSpeed;
    	motors[motorIndex].numDataPoints    = 0;
    }
  }
} // setMotorPower

/** ***************************************************************************
 * \brief  Calculates the current rotational error of the specified motor
 */
int calcError(int motorIndex)
{
  // calculate how log its been since the last encoder value was read
	long now = time1[T1];
  long deltaTime = now - motors[motorIndex].timeOfPastEncoderRead;
  
  long encoderValue = nMotorEncoder[motorIndex];
  // calculate delta rotation since the last time the encoder value was saved
  long deltaRotation = encoderValue - motors[motorIndex].savedEncoderValue;
  // save the current encoder value and the current time for the next time 
  // this routine executes
  motors[motorIndex].timeOfPastEncoderRead = now;
  motors[motorIndex].savedEncoderValue = encoderValue;

  // Calculate the current error based on the time since the last encoder 
  // value was read and the current and past encoder values.
  long speed = (deltaRotation * 1000) / deltaTime;
  int error = motors[motorIndex].targetMotorSpeed - speed;

  // save error in data point history buffer for use in integration and 
  // calculating the derivative of the error
  motors[motorIndex].errorDataPoints[motors[motorIndex].dataPointIndex] = error;
  motors[motorIndex].dataPointIndex = (motors[motorIndex].dataPointIndex+1)%maxSavedDataPoints;
  if (motors[motorIndex].numDataPoints < maxSavedDataPoints)
  {
    motors[motorIndex].numDataPoints++;
  }

  return error;
  
} // calcError

/** ***************************************************************************
 * \brief  Calculate the integral of the error for the specified motor using 
 * off the saved error terms from the past
 */
long integrateError(int motorIndex)
{
	long I = 0;
	long temp = 0;
  for (int i=0; i<= motors[motorIndex].numDataPoints-1; i++)
  {
    // note here that we're not saving off the delta time between error measurements, but 
    // using the task period instead.  This could throw off the integral slightly if the
    // task doesn't run at the specified interval.  This is unlikely and would not adversely 
    // affect the calculation
  	temp = (long)motors[motorIndex].errorDataPoints[i]*(long)motorChangeTimeInterval;
  	I = I + temp;
  }

  // return zero until we have enough data points. This prevents large integral
  // error sums when the motor is ramping up power.
  if (motors[motorIndex].numDataPoints < maxSavedDataPoints)
  {
    return 0;
  }
  else
  {
    // note here that we're dividing by the number of data points.  This 
    // normalizes the integral so that the I sum term multiplier doesn't
    // have to change when the number of data points is adjusted
    return I/(motorChangeTimeInterval*motors[motorIndex].numDataPoints);
  }

} // integrateError

/** ***************************************************************************
 * \brief This helper function is used get the correct saved error index in 
 * the case where the index is negative because the caller decremented an 
 * index of 0.  This function wouldn't be necessary if robotC implemented 
 * the mod operator properly.
 */
int indx(int i)
{
	if (i<0)
	{
		i = i + maxSavedDataPoints;
	}
	return i;
} //

/** ***************************************************************************
 * \brief Calculate the derivative of the error for the specified motor.
 */
float errorDerivative(int motorIndex)
{
	float D = 0;
	float e1;
	float e2;
  if (motors[motorIndex].numDataPoints >= 2)
  {
  	e1 = motors[motorIndex].errorDataPoints[indx(motors[motorIndex].dataPointIndex-2)];
  	e2 = motors[motorIndex].errorDataPoints[indx(motors[motorIndex].dataPointIndex-1)];
    D = (e2 - e1);
    D = D/motorChangeTimeInterval;
  }

  return D;

} // errorDerivative


/** ***************************************************************************
 * \brief Returns true if the there are enough data points to make the integral 
 * valid.
 */
bool integralValid(int motorIndex)
{
  return motors[motorIndex].numDataPoints == maxSavedDataPoints;
}

/** ***************************************************************************
 * \brief Returns true if the current motor is operating in degraded mode.
 */
bool degradedMode(int motorIndex)
{
  return motors[motorIndex].targetMotorSpeed != motors[motorIndex].setMotorSpeed;
}
/** ***************************************************************************
 * \brief Set new motor power based on PID calculations.
 */
void speedCorrect(int motorIndex)
{

  long error = calcError(motorIndex);

	long P = (error*100)/maxDegSec;

	long errorIntegral = integrateError(motorIndex);

	long I = (errorIntegral*100)/maxDegSec;

  float D = errorDerivative(motorIndex);

  int newMotorPower;

  // test to see if we're in degraded mode and the error integral is valid
  if (degradedMode(motorIndex) & integralValid(motorIndex))
  {
    // check to see if error is less than 100 degree/second.  If so
    // bump up the "degraded motor speed" in hopes of getting out of
    // the degraded mode.
  	if(abs(errorIntegral) < 100)
    {
    	if (motors[motorIndex].targetMotorSpeed > 0)
      {
      	if((motors[motorIndex].setMotorSpeed - motors[motorIndex].targetMotorSpeed) > 100)
      	{
    		  motors[motorIndex].targetMotorSpeed += 100;
    		}
        else
    		{
    		  motors[motorIndex].targetMotorSpeed = motors[motorIndex].setMotorSpeed;
    		}
    	}
      else // target motor speed is negative, so we need to reverse the sign of the calculations
      {
      	if((motors[motorIndex].setMotorSpeed - motors[motorIndex].targetMotorSpeed) < 100)
      	{
    		  motors[motorIndex].targetMotorSpeed -= 100;
    		}
    		else
    		{
    		  motors[motorIndex].targetMotorSpeed = motors[motorIndex].setMotorSpeed;
    		}
    	}
    }
  }

  // determine if degraded mode is necessary.
  // degraded mode is entered if the integral is valid and the target motor speed isn't being met.
  if (abs(errorIntegral) > abs(motors[motorIndex].targetMotorSpeed/4) &
  	   (integralValid(motorIndex))
  	 )
  {
    // reduce target speed
    motors[motorIndex].targetMotorSpeed = motors[motorIndex].targetMotorSpeed/2;
    // reset the integral calculation
    motors[motorIndex].numDataPoints = 0;
    // Recalculate error terms
    error = calcError(motorIndex);
    P = (error*100)/maxDegSec;
	  I = 0;
    D = 0;
  }

  // calculate new motor power based on PID parameters.
  // Note that P, I and D weights are hard coded in this example. 
  newMotorPower = motors[motorIndex].currentMotorPower + (P*4 + I + D*2)/5;
  if (newMotorPower > 100)
    newMotorPower = 100;
  else if (newMotorPower < -100)
    newMotorPower = -100;

  // cap new motor power based on target speed
  // note: Here is where motor calibration is critical in determining the factors between seed and power
  if ( (abs(newMotorPower*7) > abs(motors[motorIndex].targetMotorSpeed)) &
  	   (integralValid(motorIndex) | degradedMode(motorIndex))
  	 )
  {
  	newMotorPower = motors[motorIndex].targetMotorSpeed/7;
    if (newMotorPower > 0)
    {
  	  if (newMotorPower < 10)
  		  newMotorPower = 10;
    }
    else
    {
  	  if (newMotorPower > -10)
  		  newMotorPower = -10;
    }
  }

  motor[motors[motorIndex].motorID] = newMotorPower;
  motors[motorIndex].currentMotorPower = newMotorPower;

#ifdef debugPid
  nxtDisplayTextLine(0, "error %d", error);
  nxtDisplayTextLine(1, "P     %d", P);
  nxtDisplayTextLine(2, "I     %d", I);
  nxtDisplayTextLine(3, "D     %f", D);
  nxtDisplayTextLine(4, "power %d", newMotorPower);
#endif debugPid

} // speedCorrect


/** ***************************************************************************
 * \brief Warning: This is a task that should not be called directly!
 *
 * This task is started when the PID motor control is initialized. 
 */
task serviceMotorPowerChange()
{
  while(true)
  {
    for (int motorIndex = 0; motorIndex < numberOfMotors; motorIndex++)
    {
    	speedCorrect(motorIndex);
    } // for each motor

    wait1Msec(motorChangeTimeInterval);

  } // while true
} // serviceMotorPowerChange

/** ***************************************************************************
 * \brief
 */
#ifdef debugPid
task main()
{
	initialializeMotorControl(50);
	initializeIndividualMotor(motorA, 5);
	setMotorPower(motorA, 540);
	wait1Msec(60000);
	stopMotorControl();
}
#endif // debugPid

#endif
