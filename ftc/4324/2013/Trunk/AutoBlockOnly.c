#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Hubs,  S4, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     touchSensor,    sensorTouch)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     sweeper,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     FrontLeft,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     BackLeft,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     FrontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     BackRight,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_1,     flagMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     armMotor,      tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    basketServo,          tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "joystickDriver.c"
//def forward=100, 100
//def turnLeft=-100, 100
//def turnRight=100, -100
void setLeft(int motorPower)
{
	motor[FrontLeft]=motorPower;
	motor[BackLeft]=motorPower;
}

void setRight(int motorPower)
{
	motor[FrontRight]=motorPower;
	motor[BackRight]=motorPower;
}

int getLeft()
{
	return motor[FrontLeft];
}

int getRight()
{
	return motor[FrontRight];
}

void scaleMove(int leftPower, int rightPower, int driveTime)
{
	//vvv determines what direction the motors need to be powered
	int directionLeft=0; //1 is forward, -1 is reverse
	int directionRight=0;
	if (0<leftPower)
	{
		directionLeft=1;
	}
	if (0>leftPower)
	{
		directionLeft=-1;
	}
	if (0<rightPower)
	{
		directionRight=1;
	}
	if (0>rightPower)
	{
		directionRight=-1;
	}
	int counter=0; //cycle counter
	if (directionLeft==1)
	{
		setLeft(25); //set left motors to 25 power if moving forward
	}
	if (directionRight==1)
	{
		setRight(25); //set right motors to 25 power
	}
	if (directionLeft==-1)
	{
		setLeft(-25);
	}
	if (directionRight==-1)
	{
		setRight(-25);
	}
	int stepSize=3; //step size of 3 per 1Msec //vvv if any motor is not at the desired power vvv
	while(motor[FrontLeft]!=leftPower || motor[FrontRight]!=rightPower || motor[BackLeft]!=leftPower || motor[BackRight]!=rightPower)
	{
		//forward section here
		if(motor[FrontLeft]<leftPower&&directionLeft==1) //if the front left motor is less than desired power,
		{
			if(abs(leftPower-motor[FrontLeft])<stepSize) //first check to see if the difference is less than the step size
			{
				stepSize=abs(leftPower-motor[FrontLeft]); //change the step size if it is
			}
			setLeft(getLeft()+stepSize); //then increase both left motors' power by the step size
			//motor[FrontLeft]=motor[FrontLeft]+stepSize; //this is the same as what's above ^^^
			//motor[BackLeft]=motor[BackLeft]+stepSize;
		}
		if(motor[FrontRight]<rightPower&&directionRight==1) //if the frint right motor is less than desired power,
		{
			if(abs(rightPower-motor[FrontRight])<3) //first check to see if the difference is less than the step size
			{
				stepSize=abs(rightPower-motor[FrontRight]); //change the step size if it is
			}
			setRight(getRight()+stepSize); //then increase both the right motors' power by the step size
				//motor[FrontRight]=motor[FrontLeft]+3; //this is the same as what's above ^^
			//motor[BackRight]=motor[BackRight]+3;
		}
		//reverse section here
		if(motor[FrontLeft]>leftPower&&directionLeft==-1) //if the front left motor is more than the desired power, i.e.: 0 when we want -100
		{
			if(abs(leftPower-motor[FrontLeft])<stepSize) //first check to see if the difference is less than the step size
			{
				stepSize=abs(leftPower-motor[FrontLeft]); //change the step size if it is
			}
			setLeft(getLeft()-stepSize); //then decrease both the left motors by the step size
			//motor[FrontLeft]=motor[FrontLeft]-stepSize; //this is the same as whats above ^^^
			//motor[BackLeft]=motor[BackLeft]-stepSize;
		}
		if(motor[FrontRight]>rightPower&&directionRight==-1) //if the front right motor is more than the desired power, i.e.: 0 when we want -100
		{
			if(abs(rightPower-motor[FrontRight])<3) //first check to see if the difference is less than the step size
			{
				stepSize=abs(rightPower-motor[FrontRight]); //change the step size if it is
			}
			setRight(getRight()-stepSize); //then decrease both the right motors' power by the step size
			//motor[FrontRight]=motor[FrontLeft]-3; //this is the same as whats above ^^^
			//motor[BackRight]=motor[BackRight]-3;
		}
		wait1Msec(1); //wait,
		counter++; //bump the counter up one,
	} //and repeat until desired power reached
	if (counter*2>driveTime||counter>=driveTime)
	{
		motor[FrontLeft]=0;
		motor[FrontRight]=0;
		motor[BackLeft]=0;
		motor[BackRight]=0;
		return;
	}
	wait1Msec(driveTime-(counter*2)); //subtract the number of ms spent during stepping up, times two for same amount of time stepping down
	while(motor[FrontLeft]!=0 || motor[FrontRight]!=0 || motor[BackLeft]!=0 || motor[BackRight]!=0) //if any motor is not at 0
	{
		//forward section here
		if(motor[FrontLeft]>0&&directionLeft==1) //if the front left motor is greater than 0
		{
			if(abs(motor[FrontLeft])<3) //first check to see if the difference is less than the step size
			{
				stepSize=abs(motor[FrontLeft]); //change the step size if it is
			}
			setLeft(getLeft()-stepSize); //then decrease both the left motors' power by the step size
		}
		if(motor[FrontRight]>0&&directionRight==1) //if the front right motor is greater than 0
		{
			if(abs(motor[FrontRight])<3) //first check to see if the differece is less than the step size
			{
				stepSize=abs(motor[FrontRight]); //change the step size if it is
			}
			setRight(getRight()-stepSize); //then decrease both the right motors' power by the step size
		}
		//reverse section here
		if(motor[FrontLeft]<0&&directionLeft==-1) //if the front left motor is less than 0
		{
			if(abs(motor[FrontLeft])<3) //first check to see if the difference is less than the step size
			{
				stepSize=abs(motor[FrontLeft]); //change the step size if it is
			}
			setLeft(getLeft()+stepSize); //then increase both the left motors' power by the step size
		}
		if(motor[FrontRight]<0&&directionRight==-1) //if the front right motor is greater than 0
		{
			if(abs(motor[FrontRight])<3) //first check to see if the difference is less than the step size
			{
				stepSize=abs(motor[FrontRight]); //change the step size if it is
			}
		setRight(getRight()-stepSize); //then increase both right motors' power by the step size
		}
		wait1Msec(1); //wait, and repeat until all motors are stopped
	}
}

/*void forward100(int driveTime)
{
	motor[FrontLeft]=100
	motor[FrontRight]=100
	motor[BackLeft]=100
	motor[BackRight]=100
	wait1Msec(driveTime)
}*/

void turnRight(int turnTime)
{
	motor[FrontLeft]=100;
	motor[FrontRight]=-100;
	motor[BackLeft]=100;
	motor[BackRight]=-100;
	wait1Msec(turnTime);
}

void turnLeft(int turnTime)
{
	motor[FrontLeft]=-100;
	motor[FrontRight]=100;
	motor[BackLeft]=-100;
	motor[BackRight]=100;
	wait1Msec(turnTime);
}

void park()
{
	motor[FrontLeft]=0;
	motor[FrontRight]=0;
	motor[BackLeft]=0;
	motor[BackRight]=0;
}

void fullStop()
{
	park();
	wait1Msec(200); //150
}

void toBasket()
{
	scaleMove(100, 100, 600); //full power forward for 600ms
	fullStop();
}

void reverse100()
{
	motor[FrontLeft]=-100;
	motor[FrontRight]=-100;
	motor[BackLeft]=-100;
	motor[BackRight]=-100;
}

void SetupRamp()
{
	motor[FrontLeft]=100;
	motor[FrontRight]=100;
	motor[BackLeft]=100;
	motor[BackRight]=100;
	wait1Msec(875);
}
const int touchUnpressed=0;
const int basketServoDown=180;
const int basketServoUp=15;
const int armMotorUp=100;
#define bucketTime 1000
#define armTime 1600 //1600
void cycleArm()
{
	servo[basketServo]=basketServoUp; //raise bucket
	wait1Msec(bucketTime); //wait for bucket to raise
	motor[armMotor]=armMotorUp; //raise arm
	wait1Msec(armTime); //wait for arm and bucket
	motor[armMotor]=0; //stop the arm
	fullStop(); //wait for no momentum
	servo[basketServo]=basketServoDown; //drop bucket and cube
	wait1Msec(bucketTime); //process time

	servo[basketServo]=basketServoUp;
	wait1Msec(bucketTime);

	motor[armMotor]=-armMotorUp; //lower the arm
	while(SensorValue[touchSensor]==touchUnpressed){ //wait for the arm to lower

	}
	motor[armMotor]=0; //stop arm at bottom
}
task main()
{
	//waitForStart();
	toBasket(); //move to basket (forward at 100 power for 600ms)
	cycleArm();
	//scaleMove(-100, -100, 150); //reverse for 150
	//scaleMove(100, 0, 500); //turn left for 500 //right is 0 because of an unknown bug in the movement function
	//fullStop();
	//scaleMove(-100, -100, 550); //on to the ramp in reverse at 100 for 750ms
	//fullStop();
	//scaleMove(-100, 100, 500); /500
	//fullStop();
	//scaleMove(100, 100, 2000); //2000
	//fullStop();
}
