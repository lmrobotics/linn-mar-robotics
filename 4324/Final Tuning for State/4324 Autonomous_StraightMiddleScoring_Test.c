#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S3,     HTIRS2,         sensorI2CCustom)
#pragma config(Sensor, S4,     EOPD,           sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorLB,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorLF,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorRB,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorRF,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     motorLift1,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorRamp,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servoClaw,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servoMarm,            tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servoSensor,          tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/** ***************************************************************
 * \include 3rd party drivers
 * \make sure mux driver is the first
 */
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-eopd.h"
#include "drivers/hitechnic-colour-v2.h"
#include "drivers/lego-touch.h"

/** ***************************************************************
 * \light sensors connected to mux Port 3 and Port 4
 */
const tMUXSensor LightR = msensor_S2_3;
const tMUXSensor LightL = msensor_S2_4;

/** ***************************************************************
 * \motor related constants
 */
//const int motorPowerLineFollow=20; //motorPower for line follower driver
//const int motorPowerGeneral=25; // commonly used power
const int slowSpeed=25; //slow moving speed to determine angles
const int WWT=20; //Wobble Timer. Time given for the drive motors to stop wobbling

/** ***************************************************************************
 * \wheel diameters for encoder settings
 */
const float liftWheelDia=3.0; // lift wheel diameter
const float wheelDiameter=4.6; //diameter of the drive wheels with encorders
const int  revolutionPerTurn=1440; //encoder revolutions per wheel 360 degree turn
const float degreeToRevolutionConvertionFactor=11; //;
const int turnForwardRatio=5; //power ratio of left and right side for LeftTF and RightTF

/** ***************************************************************************
 * \initialize servos and lift positions
 */
void Initialize();
void readyLineFollow(int motorPower);

/** ***************************************************************************
 * \ motor movements with defined distances/degrees
 */
void Forward(int motorPower, float distanceInches);
void Backward(int motorPower, float distanceInches);
void LeftTOS(int motorPower, int turnDegrees); //left turn on spot
void RightTOS(int motorPower, int turnDegrees); //right turn on spot

void LeftTF(int motorPower, int turnDegrees); //left turn moving forward
void RightTF(int motorPower, int turnDegrees); //right turn moving forward
void armUp(int motorPower, float heightInInches); //move arm up
void armDown(int motorPower, float heightInInches); //move arm down

/** ***************************************************************************
 * \ motor movements with undefined distances/degrees
 */
void Forward(int motorPower);
void Backward(int motorPower);
void Left(int motorPower);
void Right(int motorPower);
void Stopbot();

/****************************************************************************
* \isIRHere use IR to decide if IR is on current column
*/
bool isIRHere();

/** ***************************************************************************
 * \ motor movements with undefined distances/degrees
 */
void preLineFollowTweak();
void LineFollow(int motorPower);

/** ***************************************************************************
 * \ motor movements with undefined distances/degrees
 */
task main()
{

				Initialize();
				wait10Msec(10);

        Forward(100,66);
        armUp(60,39);

        Forward(50,7);
        servo[servoClaw]=160;
        armDown(20,8);
        Backward(50,10);

        servo[servoClaw]=58;
        armDown(20,31);


}
//**** End of Main


/** ***************************************************************************
 * \ initialize servos and arm
 */
void Initialize(){
        HTEOPDsetLongRange(EOPD);
        servo[servoClaw]=58;
        servo[servoMarm]=240;
        servo[servoSensor]=185;
/*
        wait10Msec(150);
        nMotorEncoder[motorLift1]=0;
        nMotorEncoder[motorLB]=0;
        nMotorEncoder[motorRB]=0;
        motor[motorLift1]=50;
        while(nMotorEncoder[motorLift1]<6200){
                nxtDisplayTextLine(0, "%d", nMotorEncoder[motorLift1]);
                wait10Msec(1);
        }
        motor[motorLift1]=0;
        servo[servoSensor]=17;
*/
}
//** End of Initialize ()

/** *************************************************************************
* \set arm, and light sensors, and EOPD in position for line follow
*/
void readyLineFollow(int motorPower)
{
	// arm height to be decided by experiementation
	armUp(50,38);
	servo[servoSensor]=17;
}

/** ***************************************************************************
 * \ move forward function
 */
void Forward(int motorPower, float distanceInches)
{

		//	calculate encoder count target based on distance requirements
   	int encoderCountTarget=floor((revolutionPerTurn*distanceInches)/(3.14159*wheelDiameter));
    nMotorEncoder[motorLB]=0;
    nMotorEncoder[motorRB]=0;

		//change motor name accordingly
     motor[motorLF]=motorPower;
     motor[motorRF]=motorPower;
     motor[motorLB]=motorPower;
     motor[motorRB]=motorPower;

		while((nMotorEncoder[motorLB]<encoderCountTarget)&&(nMotorEncoder[motorRB]<encoderCountTarget))
		{
		}
		Stopbot();
		wait10Msec(2);
}
//end of Forward

/** ***************************************************************************
 * \ move Backward function
 */
void Backward(int motorPower, float distanceInches)
{
    nMotorEncoder[motorLB]=0;
    nMotorEncoder[motorRB]=0;

    //calculate encoder count target based on distance requirements

    int encoderCountTarget=-floor((revolutionPerTurn*distanceInches)/(3.14159*wheelDiameter));

		//change motor name accordingly

    motor[motorLF]=-motorPower;
    motor[motorRF]=-motorPower;
    motor[motorLB]=-motorPower;
    motor[motorRB]=-motorPower;

		while((nMotorEncoder[motorLB]>encoderCountTarget)&&(nMotorEncoder[motorRB]>encoderCountTarget))
		{
		}

		Stopbot();
		wait10Msec(1);
}

/** ***************************************************************************
 * \ Left Turn on Spot
 */
void LeftTOS(int motorPower, int turnDegrees)
{

    nMotorEncoder[motorLB]=0;
    nMotorEncoder[motorRB]=0;

		//calculate encoder count target based on distance requirements
		int encoderCountTarget=floor(degreeToRevolutionConvertionFactor*turnDegrees);

		// power settings
    motor[motorLF]=-motorPower;
    motor[motorRF]=motorPower;
    motor[motorLB]=-motorPower;
    motor[motorRB]=motorPower;
		while((nMotorEncoder[motorLB]>(-encoderCountTarget))&&(nMotorEncoder[motorRB]<encoderCountTarget))
		{
		}
		Stopbot();
		wait10Msec(1);
}

/** ***************************************************************************
 * \ Right Turn on Spot
 */
void RightTOS(int motorPower, int turnDegrees)
{

    nMotorEncoder[motorLB]=0;
    nMotorEncoder[motorRB]=0;

    // calculate encoder count target based on distance requirements
		int encoderCountTarget=floor(degreeToRevolutionConvertionFactor*turnDegrees);

 		// power settings
    motor[motorLF]=motorPower;
    motor[motorRF]=-motorPower;
    motor[motorLB]=motorPower;
    motor[motorRB]=-motorPower;
		while((nMotorEncoder[motorLB]<encoderCountTarget)&&(nMotorEncoder[motorRB]>(-encoderCountTarget)))
		{
		}
		Stopbot();
		wait10Msec(1);
}//end of RightTOS

/** ***************************************************************************
 * \ Left Turn moving forward
 */
void LeftTF(int motorPower, int turnDegrees){

   	nMotorEncoder[motorLB]=0;
   	nMotorEncoder[motorRB]=0;

		// calculate encoder count target based on distance requirements
    int encoderCountTargetL=floor(degreeToRevolutionConvertionFactor*turnDegrees/turnForwardRatio);
    int encoderCountTargetR=floor(degreeToRevolutionConvertionFactor*turnDegrees*turnForwardRatio);

		// change motor power accordingly
		motor[motorLF]=15;
    motor[motorRF]=100;
    motor[motorLB]=15;
    motor[motorRB]=100;
		while((nMotorEncoder[motorLB]<encoderCountTargetL)&&(nMotorEncoder[motorRB]<encoderCountTargetR))
		{
        }
		Stopbot();
		wait10Msec(10);
}//end of LeftTF

/** ***************************************************************************
 * \ Right Turn moving forward
 */
void RightTF(int motorPower, int turnDegrees){


    nMotorEncoder[motorLB]=0;
    nMotorEncoder[motorRB]=0;

    //calculate encoder count target based on distance requirements
    int encoderCountTargetL=floor(degreeToRevolutionConvertionFactor*turnDegrees*turnForwardRatio);
    int encoderCountTargetR=floor(degreeToRevolutionConvertionFactor*turnDegrees/turnForwardRatio);

		// change motor power accordingly
    motor[motorLF]=100;
    motor[motorRF]=15;
    motor[motorLB]=100;
    motor[motorRB]=15;
		while((nMotorEncoder[motorLB]<encoderCountTargetL)&&(nMotorEncoder[motorRB]<encoderCountTargetR))
		{
        }
		Stopbot();
		wait10Msec(1);
}//end of RightTF

/** ********************************************************************************
 * \armUp, encounter counts up
 */
void armUp(int motorPower, float heightInInches) //move arm up or down
{
		nMotorEncoder[motorLift1]=0;
    motor[motorLift1]=motorPower;
    int armEncoderTarget = floor((revolutionPerTurn*heightInInches)/(3.14159*liftWheelDia));
    while(nMotorEncoder[motorLift1]<armEncoderTarget)
      {
      }
    motor[motorLift1]=0;
}//end of armUp

/** *******************************************************************************
 * \armDown, encounter counts down
 */
void armDown(int motorPower, float heightInInches) //move arm up or down
{
		nMotorEncoder[motorLift1]=0;
    motor[motorLift1]=-motorPower;
    int armEncoderTarget = -floor((revolutionPerTurn*heightInInches)/(3.14159*liftWheelDia));
    while(nMotorEncoder[motorLift1]>armEncoderTarget)
     {
     }
    motor[motorLift1]=0;
}//end of armDown


/** ***************************************************************************
 * \move forward
 */
void Forward(int motorPower){
        motor[motorLF]=motorPower;
        motor[motorRF]=motorPower;
        motor[motorLB]=motorPower;
        motor[motorRB]=motorPower;
}// end of Forward

/** ***************************************************************************
 * \move Backward
 */
void Backward(int motorPower){
        motor[motorLF]=-motorPower;
        motor[motorRF]=-motorPower;
        motor[motorLB]=-motorPower;
        motor[motorRB]=-motorPower;
}// end of Backward

/** ****************************************************************************
 * \Left turn on spot
 */
void Left(int motorPower)
{
        motor[motorLF]=-motorPower;
        motor[motorRF]=motorPower;
        motor[motorLB]=-motorPower;
        motor[motorRB]=motorPower;
}//end of Left

/** ****************************************************************************
 * \Right turn on spot
 */
void Right(int motorPower)
{
        motor[motorLF]=motorPower;
        motor[motorRF]=-motorPower;
        motor[motorLB]=motorPower;
        motor[motorRB]=-motorPower;
}// end of Right

/** ****************************************************************************
 * \Stop robot
 */
void Stopbot()
{
        motor[motorLF]=0;
        motor[motorRF]=0;
        motor[motorLB]=0;
        motor[motorRB]=0;
}//end of Stop
//End of movements with nondefined distances

/** ***************************************************************************
 * \pre-line following tweak turn robot straight based on which direction
 * \it approaches the line
 */
void preLineFollowTweak(){

		///Encoder count to decide the angle the robot is approaching he line,
		//used to decide how much the robot to should turn to be ready for line-following
   	int leftLightReading=0;
  	int rightLightReading=0;

		// move till one of the two light sensors find the line
    motor[motorLF]=slowSpeed;
    motor[motorRF]=slowSpeed;
    motor[motorLB]=slowSpeed;
    motor[motorRB]=slowSpeed;
    while ((SensorValue[LightL]<35) && (SensorValue[LightR]<35))
      {
      }
    Stopbot();
    leftLightReading=SensorValue[LightL];
    rightLightReading=SensorValue[LightR];
    wait10Msec(2);

    if (leftLightReading<rightLightReading)
      {
				// Distance to be tweaked by experiment
        Forward(15,6); // distance to be tweaked
        Left(15);
        while ((SensorValue[LightL])<30 && (SensorValue[LightR]<30))
        {
        }
        Stopbot();
        wait1Msec(20);
      }

    if (leftLightReading>rightLightReading)
      {
				// istance to be tweaked by experiment
        Forward(15,6); // distance to be tweaked
        Right(15);
        while ((SensorValue[LightL])<30 && (SensorValue[LightR]<30))
          {
          }
        Stopbot();
        wait1Msec(20);

      }
}//end of preLineFollowTweak

/** ***************************************************************************
 * \line following function
 */
void LineFollow(int motorPower){
        HTEOPDsetLongRange(EOPD);
        bool Foundpeg=false;
        bool FoundLine=false;
        bool FirstSign=false;    //false=- , True=+
        int Delta=0;
        int LStart=16;
        int RStart=15;
        //Section 1a: Find the line
        motor[motorLF]=motorPower;
        motor[motorRF]=motorPower;
        motor[motorLB]=motorPower;
        motor[motorRB]=motorPower;
        nxtDisplayTextLine(0,"Finding Line");
        while (FoundLine==false){
                Delta=(SensorValue[LightL]-LStart)-(SensorValue[LightR]-RStart);
                if (SensorValue[LightL]>22 || SensorValue[LightR]>22){
                        FoundLine=true;
                        if (Delta>0){
                                FirstSign=true;
                        }
                }
                wait10Msec(1);
        }
        Stopbot();
        wait10Msec(100);
        FoundLine=false;
        Foundpeg=false;
        nxtDisplayTextLine(0,"Small Turns");
        while (Foundpeg==false){
                Delta=(SensorValue[LightL]-LStart)-(SensorValue[LightR]-RStart);
                motor[motorRF]=motorPower+Delta*.5;
                motor[motorLF]=motorPower-Delta*.5;
                motor[motorRB]=motorPower+Delta*.5;
                motor[motorLB]=motorPower-Delta*.5;
                if (HTEOPDreadRaw(EOPD)>=20){
                        Foundpeg=true;
                        Stopbot();
                }
                wait10Msec(1);
        }
}//end of LineFollow

/************************************************************************
* \IR seeker read modulated zune acS3
* \signal strength higher than 90 means IR beacon on current column
*/
bool isIRHere()
{

	// set he default DSP mode is 1200 Hz.
  HTIRS2setDSPMode(HTIRS2, DSP_1200);

//acS1 to acS5 are non processed zones
 	int acS1, acS2, acS3, acS4, acS5 = 0;
	HTIRS2readAllACStrength(HTIRS2, acS1, acS2, acS3, acS4, acS5 );

	//return true if iR is on current column
	if (acS3>90)
	{
     return true;
     nxtDisplayCenteredTextLine(2,"%d",acS3);
     wait10Msec(500);

  }
 	else
 	{
   	return false;
   	nxtDisplayCenteredTextLine(2,"%d",acS3);
   	wait10Msec(500);
 	}
}//end of iIRHere
