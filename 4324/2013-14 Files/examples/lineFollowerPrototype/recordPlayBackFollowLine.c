#pragma config(Sensor, S1,     rightLightSensor, sensorLightActive)
#pragma config(Sensor, S2,     touchSensor,    sensorTouch)
#pragma config(Sensor, S3,     leftLightSensor, sensorLightActive)
#pragma config(Motor,  motorA,          rightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "JoyStickRecordDriver.c"
#include "MotorControlDriver.c"
#include "followLine.c"
#pragma platform(Tetrix)

/** ***************************************************************************
 * \brief Limit val at high end to 100 and to -100 at low end. If absolute
 * value of val is less than limit, 0 is returned.
 *
 * \param[in] val - Input value to apply limits to.
 *
 * \param[in] limit - If absolute value of val is less that limit parameter, 0
 * is returned.
 *
 * \return val limited beteen -100 and 100.  0 is returned if val is between -limit and + limit.
 */
int slowStopLimit(int val, int limit = 6)
{
   if ((val < limit) && (val > -limit))
   {
     val = 0;
   }

  if (val>100)
    val = 100;

  if (val < -100)
    val = -100;

   return val;
}

/** ***************************************************************************
 * \brief Sets motor speeds based on current joystick data
 *
 * \param currentJoystick - current joystick event data.
 */
void motorControl(TJoystick currentJoystick)
{
	float x = (float)currentJoystick.joy1_x2;
	float y = (float)currentJoystick.joy1_y2;

  float r = sqrt(x*x + y*y);
  float pf = r*100.0/128.0;
  nxtDisplayTextLine(0, "x = %f", x);
  nxtDisplayTextLine(1, "y = %f", y);
  nxtDisplayTextLine(2, "pf = %f", pf);
  nxtDisplayTextLine(3, "r = %f", r);

  //float leftPower = (y/r + x/r)*pf;
  //float rightPower  = (y/r - x/r)*pf;

  // tank drive
  float leftPower  = (currentJoystick.joy1_y1*100)/128;
  float rightPower = (currentJoystick.joy1_y2*100)/128;

  nxtDisplayTextLine(4, "rgt = %d", slowStopLimit((int)rightPower));
  nxtDisplayTextLine(5, "lft = %d", slowStopLimit((int)leftPower) );

  setMotorPower(leftMotor,  slowStopLimit((int)leftPower) );
  setMotorPower(rightMotor, slowStopLimit((int)rightPower));

}

/** ***************************************************************************
 * \brief Performs robot control based on current joystick data
 *
 * \param currentJoystick - current joystick event data.
 *
 * \return true if button RB is pressed.
 */
bool processJoystick(TJoystick currentJoystick)
{

  // set motor speed
  motorControl(currentJoystick);

  // return true if button RB is pressed
  return (currentJoystick.joy1_Buttons & 32) != 0;

} // processJoystick

/** ***************************************************************************
 * \brief main robot task. Determines mode then performs main processing loop.
 *
 */
task main()
{
  bool exit = false;
  string eventFileName = "carData.bin";
  typedef enum {normalOperation, recordMode, playbackMode} modeType;
  modeType mode;

  PlaySound(soundUpwardTones);

  // disable joystick diagnostic
  disableDiagnosticsDisplay();
  initializeIndividualMotor(rightMotor, 50);
  initializeIndividualMotor(leftMotor, 50);
  initialializeMotorControl(1);

  exit = false;
  // determine mode
  while (!exit)
  {
    getJoystickSettings(joystick);

    // button X starts normal drive mode
    if (joystick.joy1_Buttons & 1)
    {
      mode = normalOperation;
      initalizeJoystickRecording(eventFileName, record);
      exit = true;
    }

    // button A starts recording mode
    if (joystick.joy1_Buttons & 2)
    {
      mode = recordMode;
      initalizeJoystickRecording(eventFileName, record);
      exit = true;
    }
    // button B starts playback mode
    if (joystick.joy1_Buttons & 4)
    {
      mode = playbackMode;
      initalizeJoystickRecording(eventFileName, playBack);
      exit = true;
    }
  } // while waiting for startup mode button press

  if (mode == normalOperation)
  {
    exit = false;
    while (!exit)
    {
      getJoystickSettings(joystick);
      exit = processJoystick(joystick);
    } // while(true)
  }
  else // mode is either record or playback
  {
    TJoystick currentJoystick;
    exit = false;
    while (!exit)
    {
  	  getJoystickValues(currentJoystick);
      exit = processJoystick(currentJoystick);
    } // while
  } // if record/playback mode

  // start following line
  follow();

  // write out joystick events if bot is in recode mode.
  if (mode == recordMode)
  {
    writeEvents();
  }

} // main
