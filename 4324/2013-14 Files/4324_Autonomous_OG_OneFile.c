#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S3,     HTIRS2,         sensorI2CCustom)
#pragma config(Sensor, S4,     EOPD,           sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorLB,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorLF,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorRB,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorRF,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     motorLift1,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorRamp,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servoClaw,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servoMarm,            tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servoSensor,          tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-eopd.h"
#include "drivers/hitechnic-colour-v2.h"
#include "drivers/lego-touch.h"

/** ***************************************************************************
* Light sensors on Mux port 3 and 4
*/

const tMUXSensor LightR = msensor_S2_3;
const tMUXSensor LightL = msensor_S2_4;

const int motorPowerLineFollow=20; //motorPower for line follower driver
const int motorPowerGeneral=25;	// commonly used power
const int WWT=20;				//Wobble Timer. Time given for the drive motors to stop wobbling

const float wheelDiameter=4.0; //diameter of the wheels with encorder
const int	revolutionPerTurn=1440; //encoder revolutions per wheel 360 degree turn

const int slowSpeed=25;	//slow moving speed to determine angles
const int maxEncoderCount=2880; // max encoder count for straight movement, no
 																	//tweak required if motor moves this far.

void Initialize();
/*******************************************
* Indefinite movement functions
*/
void Forward(int motorPower);
void Backward(int motorPower);
void Left(int motorPower);
void Right(int motorPower);

/*************************************
* Definite movement functions
*/
void Forward(int motorPower, float distanceInches);
void Backward(int motorPower, float distanceInches);
void Left(int motorPower, int turnDegrees);
void Righ(int motorPower, int turnDegrees);

void Stopbot();

//****************************************

void preLineFollowTweak();
void LineFollow(int motorPower);


task main(){
	Initialize();																										//Initialize
	wait10Msec(200);

// Move forward till close to the middle line
	Forward(50,40); //move forward 40 inches
	Stopbot();
	wait1Msec(20);

// Find the line, then turn the robot to almost straight
	preLineFollowTweak();

// Line following
	LineFollow(motorPowerLineFollow);																								//line follow
	Stopbot();
	wait10Msec(WWT);

	servo[servoMarm]=20;																						//Place ring
	servo[servoClaw]=100;
	wait10Msec(200);
	motor[motorLift1]=-50;
	while(nMotorEncoder[motorLift1]>5000){
		nxtDisplayTextLine(0, "%d", nMotorEncoder[motorLift1]);
		wait10Msec(1);
	}
	motor[motorLift1]=0;
	wait10Msec(50);
	/*
	Right();
	wait10Msec(50);
	*/
	Backward(motorPowerGeneral,10);
	wait10Msec(100);
	Stopbot();
	wait10Msec(WWT);
}

//*****************************************************
void Initialize(){
	HTEOPDsetLongRange(EOPD);
	servo[servoClaw]=58;
	servo[servoMarm]=240;
	servo[servoSensor]=185;
	wait10Msec(150);
	nMotorEncoder[motorLift1]=0;
	nMotorEncoder[motorLB]=0;
	nMotorEncoder[motorRB]=0;
	motor[motorLift1]=50;
	while(nMotorEncoder[motorLift1]<6200){
		nxtDisplayTextLine(0, "%d", nMotorEncoder[motorLift1]);
		wait10Msec(1);
	}
	motor[motorLift1]=0;
	servo[servoSensor]=17;
}
//********************************************************

void Forward(int motorPower, float distanceInches){

/** ***************************************************************************
 * calculate encoder count target based on distance requirements
 */
		int encoderCountTarget=revolutionPerTurn*floor(distanceInches/(3.14159*wheelDiameter));

		nMotorEncoder[motorLB]=0;
		nMotorEncoder[motorRB]=0;
/** ***************************************************************************
 * change motor name accordingly
 */
 		motor[motorLF]=motorPower;
		motor[motorRF]=motorPower;
		motor[motorLB]=motorPower;
		motor[motorRB]=motorPower;

 while((nMotorEncoder[motorLB]<encoderCountTarget)&&(nMotorEncoder[motorRB]<encoderCountTarget))
   {
			wait1Msec(5);
			nxtDisplayBigTextLine(3,"%d",nMotorEncoder[motorLB]);
		}
}

void Backward(int motorPower, float distanceInches){

		nMotorEncoder[motorLB]=0;
		nMotorEncoder[motorRB]=0;
	/** ***************************************************************************
 * calculate encoder count target based on distance requirements
 */
		int encoderCountTarget=revolutionPerTurn*floor(distanceInches/(3.14159*wheelDiameter));

		/** ***************************************************************************
 * change motor name accordingly
 */
	motor[motorLF]=-motorPower;
	motor[motorRF]=-motorPower;
	motor[motorLB]=-motorPower;
	motor[motorRB]=-motorPower;

 while((nMotorEncoder[motorLB]<encoderCountTarget)&&(nMotorEncoder[motorRB]<encoderCountTarget))
   {
			wait1Msec(5);
	 }
}

void Left(int motorPower)
{
        motor[motorLF]=-motorPower;
        motor[motorRF]=motorPower;
        motor[motorLB]=-motorPower;
        motor[motorRB]=motorPower;
}

void Right(int motorPower)
{
        motor[motorLF]=motorPower;
        motor[motorRF]=-motorPower;
        motor[motorLB]=motorPower;
        motor[motorRB]=-motorPower;
}

void Stopbot()
{
        motor[motorLF]=0;
        motor[motorRF]=0;
        motor[motorLB]=0;
        motor[motorRB]=0;
}


//**********************************************************
//
void preLineFollowTweak(){

/** ***************************************************************************
 * Encoder count to decide the angle the robot is approaching the line,
 * used to decide how much the robot to should turn to be ready for line-following
 */
 	int leftLightReading=0;
 	int rightLightReading=0;

/** ***************************************************************************
 * move till one of the two light sensors find the line
 */
	motor[motorLF]=slowSpeed;
	motor[motorRF]=slowSpeed;
	motor[motorLB]=slowSpeed;
	motor[motorRB]=slowSpeed;
	while ((SensorValue[LightL]<35) && (SensorValue[LightR]<35))
		{
			wait1Msec(2);
		}
	Stopbot();
	leftLightReading=SensorValue[LightL];
	rightLightReading=SensorValue[LightR];
	wait10Msec(2);

 	if (leftLightReading<rightLightReading){
/** ***************************************************
* Distance to be tweaked by experiment
*/
 		Forward(15,6); // distance to be tweaked
 		Left(15);
 		while ((SensorValue[LightL])<30 && (SensorValue[LightR]<30)){
			wait1Msec(2);
		}
		Stopbot();
		wait1Msec(20);
	}

	if (leftLightReading>rightLightReading)
	{
/** ***************************************************
* Distance to be tweaked by experiment
*/
 		Forward(15,6); // distance to be tweaked
 		Right(15);
 		while ((SensorValue[LightL])<30 && (SensorValue[LightR]<30))
 			{
				wait1Msec(2);
			}
		Stopbot();
		wait1Msec(20);

	}
}

//**********************************************
void LineFollow(int motorPower){					//true=Turn Right when found line, false=Turn Left when found line
	HTEOPDsetLongRange(EOPD);
	bool Foundpeg=false;
	bool FoundLine=false;
	bool FirstSign=false;										//false=- , True=+
	int Delta=0;
	int LStart=16;
	int RStart=15;
	//Section 1a: Find the line
	motor[motorLF]=motorPower;
	motor[motorRF]=motorPower;
	motor[motorLB]=motorPower;
	motor[motorRB]=motorPower;
	nxtDisplayTextLine(0,"Finding Line");
	while (FoundLine==false){
		Delta=(SensorValue[LightL]-LStart)-(SensorValue[LightR]-RStart);
		if (SensorValue[LightL]>22 || SensorValue[LightR]>22){
			FoundLine=true;
			if (Delta>0){
				FirstSign=true;
			}
		}
		wait10Msec(1);
	}
	Stopbot();
	wait10Msec(100);
	FoundLine=false;
	Foundpeg=false;
	nxtDisplayTextLine(0,"Small Turns");
	while (Foundpeg==false){
		Delta=(SensorValue[LightL]-LStart)-(SensorValue[LightR]-RStart);
		motor[motorRF]=motorPower+Delta*.5;
		motor[motorLF]=motorPower-Delta*.5;
		motor[motorRB]=motorPower+Delta*.5;
		motor[motorLB]=motorPower-Delta*.5;
		if (HTEOPDreadRaw(EOPD)>=20){
			Foundpeg=true;
			Stopbot();
		}
		wait10Msec(1);
	}
}
