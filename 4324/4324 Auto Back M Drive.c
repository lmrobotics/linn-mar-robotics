#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     LightR,         sensorLightActive)
#pragma config(Sensor, S3,     LightL,         sensorLightActive)
#pragma config(Sensor, S4,     EOPD,           sensorI2CCustom)
#pragma config(Motor,  motorA,          motorWall,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorLF,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorLB,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorRF,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorRB,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorLift1,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorLift2,    tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servoClaw,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servoMarm,            tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servoSensor,          tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma debuggerWindows("joystickSimple")
#include "drivers/hitechnic-sensormux.h"
#include "JoystickDriver.c"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-eopd.h"
#include "drivers/hitechnic-colour-v2.h"
#include "drivers/lego-touch.h"

const int MP=15;				//Motor power of Drive wheels
const int EWT=20;				//Wobble Timer. Time given for the Elevator motors to stop wobbling
const int WWT=20;				//Wobble Timer. Time given for the drive motors to stop wobbling

void Forward();
void Backward();
void Left();
void Right();
void Stopbot();
void LineFollow(bool Direction);			//True=Right, False=Left
void Initialize();										//Initialize the robot
//int Scan();														//+ = Right , - = Left
/*
const tMUXSensor EOPD = msensor_S4_1;
const tMUXSensor IRFind = msensor_S4_2;
const tMUXSensor Touch = msensor_S4_3;
*/
task main(){
	HTEOPDsetLongRange(EOPD);
	Initialize();
	wait10Msec(200);
	/*
	int ScanVal=Scan();
	if(ScanVal>=0){
		LineFollow(true);
	}
	else{
		LineFollow(false);
	}
	*/
	LineFollow(true);
	Stopbot();
	servo[servoMarm]=55;
	wait10Msec(200);
	Right();
	wait10Msec(50);
	Backward();
	wait10Msec(100);
	Stopbot();
}

void Forward(){
	motor[motorLF]=MP;
	motor[motorRF]=MP;
	motor[motorLB]=MP;
	motor[motorRB]=MP;
}

void Backward(){
	motor[motorLF]=-MP;
	motor[motorRF]=-MP;
	motor[motorLB]=-MP;
	motor[motorRB]=-MP;
}

void Left(){
	motor[motorLF]=-MP;
	motor[motorRF]=MP;
	motor[motorLB]=-MP;
	motor[motorRB]=MP;
}

void Right(){
	motor[motorLF]=MP;
	motor[motorRF]=-MP;
	motor[motorLB]=MP;
	motor[motorRB]=-MP;
}

void Stopbot(){
	motor[motorLF]=0;
	motor[motorRF]=0;
	motor[motorLB]=0;
	motor[motorRB]=0;
	wait10Msec(WWT);
}

void Initialize(){
	HTEOPDsetLongRange(EOPD);
	servo[servoClaw]=38;
	servo[servoMarm]=240;
	servo[servoSensor]=185;
	wait10Msec(150);
	nMotorEncoder[motorLift1]=0;
	/*
	motor[motorLift1]=50;
	while(nMotorEncoder[motorLift1]<5000){
		nxtDisplayTextLine(0, "%d", nMotorEncoder[motorLift1]);
		wait10Msec(1);
	}
	motor[motorLift1]=0;
	*/
	servo[servoSensor]=15;
}

void LineFollow(bool Direction){					//true=Turn Right when found line, false=Turn Left when found line
	HTEOPDsetLongRange(EOPD);
	bool Foundpeg=false;
	bool FoundLine=false;
	bool FirstSign=false;										//false=- , True=+
	int Delta=0;
//	int LStart=SensorValue[LightL];
//	int RStart=SensorValue[LightR];
	int LStart=16;
	int RStart=15;
	//Section 1a: Find the line
	motor[motorLF]=MP;
	motor[motorRF]=MP;
	motor[motorLB]=MP;
	motor[motorRB]=MP;
	nxtDisplayTextLine(0,"Finding Line");
	while (FoundLine==false){
		Delta=(SensorValue[LightL]-LStart)-(SensorValue[LightR]-RStart);
		if (SensorValue[LightL]>22 || SensorValue[LightR]>22){
			FoundLine=true;
			if (Delta>0){
				FirstSign=true;
			}
		}
		wait10Msec(1);
	}
	Stopbot();
	wait10Msec(100);
	FoundLine=false;
	/*
	if (Direction==true){
		motor[motorLF]=MP;
		motor[motorRF]=MP;
		motor[motorLB]=MP;
		motor[motorRB]=MP;
		nxtDisplayTextLine(0,"Moving Forward");
		wait10Msec(80);
		motor[motorRF]=-11;
		motor[motorRB]=-11;
	}
	else {
		motor[motorLF]=MP;
		motor[motorRF]=MP;
		motor[motorLB]=MP;
		motor[motorRB]=MP;
		nxtDisplayTextLine(0,"Moving Forward");
		wait10Msec(100);
		motor[motorLF]=-11;
		motor[motorLB]=-11;
	}
	nxtDisplayTextLine(0,"Turning onto line");
	while (FoundLine==false){
		Delta=(SensorValue[LightL]-LStart)-(SensorValue[LightR]-RStart);
		if (SensorValue[LightL]>22 || SensorValue[LightR]>22){
			FoundLine=true;
		}
	}
	wait10Msec(40);
	Stopbot();
	*/
	/*
	//Section 3: Big turns
	nxtDisplayTextLine(0,"Big Turns");
	while (Foundpeg==false){
		Delta=(SensorValue[LightL]-LStart)-(SensorValue[LightR]-RStart);
		motor[motorRF]=MP+Delta;
		motor[motorLF]=MP-Delta;
		motor[motorRB]=MP+Delta;
		motor[motorLB]=MP-Delta;
		if (HTEOPDreadRaw(EOPD)>1){
			Foundpeg=true;
		}
		wait10Msec(1);
	}
	*/
	Foundpeg=false;
	nxtDisplayTextLine(0,"Small Turns");
	while (Foundpeg==false){
		Delta=(SensorValue[LightL]-LStart)-(SensorValue[LightR]-RStart);
		motor[motorRF]=MP+((Delta*1)/3);
		motor[motorLF]=MP-((Delta*1)/3);
		motor[motorRB]=MP+((Delta*1)/3);
		motor[motorLB]=MP-((Delta*1)/3);
		if (HTEOPDreadRaw(EOPD)>=18){
			Foundpeg=true;
			Stopbot();
		}
		wait10Msec(1);
	}
}
/*
int Scan()
{
	bool seek=false;
	int Direction=0;
	int MaxIR=0;
	int IR1=0;
	int IR2=0;
	int IR3=0;
	int IR4=0;
	int IR5=0;
	int Turn=0;
	while (TSreadState(Touch)==true){
		//nxtDisplayTextLine(0, "%d", HTIRS2readDCDir(IRFind));
		HTIRS2readAllACStrength(IRFind, IR1, IR2, IR3, IR4, IR5);
		if (IR2>2){
			Right();
			seek=true;
			Direction=1;
		}
		else if (IR4>2){
			Left();
			seek=true;
			Direction=-1;
		}
		else {
			if (seek==true){
				HTIRS2readAllACStrength(IRFind, IR1, IR2, IR3, IR4, IR5);
				MaxIR=IR3;
				while (IR3>MaxIR-10){
					HTIRS2readAllACStrength(IRFind, IR1, IR2, IR3, IR4, IR5);
					if (IR3>MaxIR){
						MaxIR=IR3;
					}
					nxtDisplayTextLine(0, "%d %d %d %d %d", IR1, IR2, IR3, IR4, IR5);
					Turn+=Direction;
					wait10Msec(1);
				}
				if (Direction==1)
					Left();
				else
					Right();
				while (IR3>MaxIR-5){
					HTIRS2readAllACStrength(IRFind, IR1, IR2, IR3, IR4, IR5);
					nxtDisplayTextLine(0, "%d %d %d %d %d", IR1, IR2, IR3, IR4, IR5);
					Turn+=(-Direction);
					wait10Msec(1);
				}
				seek=false;
				Stopbot();
				Direction=0;
			}
			else{
				Forward();
				seek=false;
				Direction=0;
			}
		}
		nxtDisplayTextLine(0, "%d %d %d %d %d", IR1, IR2, IR3, IR4, IR5);
		Turn+=Direction;
		wait10Msec(1);
	}
	return Turn;
}
*/
