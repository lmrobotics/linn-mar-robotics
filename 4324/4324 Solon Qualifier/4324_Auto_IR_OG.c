#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTServo,  HTMotor,  none,     none)
#pragma config(Sensor, S3,     HTMux,          sensorI2CCustom)
#pragma config(Sensor, S4,     IRFind,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorArmUpDown, tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorArmRotate, tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorB,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorF,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorL,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     motorR,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     motorWall,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    servoClaw,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    servoCGrip,           tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servoIR,              tServoStandard)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-eopd.h"
#include "drivers/hitechnic-colour-v1.h"

//two sensors were connected to multiplexer
const tMUXSensor EOPD = msensor_S3_1;	//change sensor port accordingly
const tMUXSensor Color = msensor_S3_2;	//change sensor port accordingly

//Function declarations
void Stopbot();						//Stop the robot
void Forward();						//Move the robot Forward
void Back();							//Move the robot Back
void Left();							//Move the robot Left
void Right();							//Move the robot Right
void TLeft();							//Turn the robot Left
void TRight();						//Turn the robot Right
int Scan();

//Constants

const int MP=50;				//Motor power of Drive wheels
const int AWT=20;				//Wobble Timer. Time given for the arm motors to stop wobbling
const int WWT=20;				//Wobble Timer. Time given for the drive motors to stop wobbling

//*****************************************************
//how does this work:
//If Scan()>-15, beacon is on the right side so go straight
//Otherwise, beacon is on the left so slide left
//*****************************************************

task main()
{
	int EStop=0;									//Emergency Stop the motors if board cannot be detected. Stops the Search when EStop>150
	nMotorEncoder[motorArmRotate]=0;
	nMotorEncoder[motorArmUpDown]=0;
	//Color Sensor Readings (Current)
	int CRed=0;
	int CBlue=0;
	int CGreen=0;
	int SGreen=0;
	int InvBatt=90;

	if (Scan()<-15){								//Perform the Scan

		//beacon is on the left side
		//so slide left first
//*********CRITICAL VALUES**********
		Stopbot();
		Left();
		wait10Msec(130);
		Stopbot();

		//move forward till reaches the center floor
		//detected by color sensor reading SGreen<=15
		motor[motorF]=0;
		motor[motorL]=25;
		motor[motorR]=-25;
		motor[motorB]=0;
		HTCSreadRGB(Color, CRed, CGreen, CBlue);
		SGreen=CGreen;
		EStop=0;
		while(SGreen>15){
			HTCSreadRGB(Color, CRed, CGreen, CBlue);
			wait10Msec(1);
			SGreen=CGreen;
			EStop++;
			if (EStop>100){
				SGreen=1;
			}
		}
		wait10Msec(20);
		Stopbot();
		Back();						//back slightly so wheels are not on board
		wait10Msec(10);
		Stopbot();

		//now slide the robot left along the edge of
		//the center floor till reaches the white line
		//detected by color sensor SGGreen>=50
		motor[motorF]=-20;
		motor[motorB]=60;
		EStop=0;
		HTCSreadRGB(Color, CRed, CGreen, CBlue);
		SGreen=CGreen;
		while(SGreen<50){
			HTCSreadRGB(Color, CRed, CGreen, CBlue);
			wait10Msec(1);
			SGreen=CGreen;
			EStop++;
			if (EStop>200){
				SGreen=100;
			}
		}
		Stopbot();

		//now move the robot backward certain distance
		//counted by encoder
		//initialize encoder values to be negative 1 so 0 indicates broken wire or loss connection

		nMotorEncoder[motorL]=0;
		nMotorEncoder[motorR]=0;
		Back();
  	while ((nMotorEncoder[motorL]>-1440*5)||(nMotorEncoder[motorL]>-1440*5)) //while the encoder wheel turns one revolution
  	{
  	}
		Stopbot();


		//now scan IR again and determine which peg is the IR beacon on
		//Second Scan. Move arm into position
		nMotorEncoder[motorArmRotate]=-1;
		if (Scan()>10){

			//*********CRITICAL VALUES**********
			motor[motorArmRotate]=-13;
			while ((nMotorEncoder[motorArmRotate]>-700)&&(nMotorEncoder[motorArmRotate]!=0)){
				wait1Msec(1);
			}
			motor[motorArmRotate]=0;
			wait10Msec(AWT);
		}
		else{
			//*********CRITICAL VALUES**********
			motor[motorArmRotate]=-13;
			while (nMotorEncoder[motorArmRotate]>-1050){
				wait1Msec(1);
			}
			motor[motorArmRotate]=0;
			wait10Msec(AWT);
			Forward();
			wait10Msec(100);
			Stopbot();
			Left();
			wait10Msec(20);
			Stopbot();
		}
	}

	else {
		//*********CRITICAL VALUES**********
		Stopbot();
		Forward();
		wait10Msec(130);						//Variable based on battery
		Stopbot();

		motor[motorF]=-25;
		motor[motorL]=0;
		motor[motorR]=0;
		motor[motorB]=25;
		EStop=0;
		HTCSreadRGB(Color, CRed, CGreen, CBlue);
		SGreen=CGreen;
		while(SGreen>15){
			HTCSreadRGB(Color, CRed, CGreen, CBlue);
			wait10Msec(1);
			SGreen=CGreen;
			EStop++;
			if (EStop>100){
				SGreen=1;
			}
		}
		Stopbot();
		Back();
		wait10Msec(5);
		Stopbot();

		motor[motorL]=60;
		motor[motorR]=-20;
		EStop=0;
		HTCSreadRGB(Color, CRed, CGreen, CBlue);
		SGreen=CGreen;
		while(SGreen<50){
			HTCSreadRGB(Color, CRed, CGreen, CBlue);
			wait10Msec(1);
			SGreen=CGreen;
			EStop++;
			if (EStop>200){
				SGreen=100;
			}
		}
		Stopbot();

		wait10Msec((InvBatt*5)/3);					//Variable based on battery. 100 or 80
		Right();
		wait10Msec((InvBatt*4)/3);					//Variable based on battery. 75 or 55
		Stopbot();
		TLeft();
		wait10Msec((InvBatt*4)/3);					//Variable based on battery. 50
		Stopbot();
		Back();
		wait10Msec(InvBatt);								//Variable based on battery. 40 or 60
		Stopbot();
		//Second Scan. Move the arm into position
		Stopbot();
		nMotorEncoder[motorArmRotate]=0;
		if (Scan()>10){

			//*********CRITICAL VALUES**********
			motor[motorArmRotate]=-13;
			while (nMotorEncoder[motorArmRotate]>-600){
				wait1Msec(1);
			}
			motor[motorArmRotate]=0;
			wait10Msec(AWT);
			Forward();
			wait10Msec((InvBatt*4)/3);
			Left();
			wait10Msec((InvBatt*2)/3);
			Stopbot();
		}
		else{
			motor[motorArmRotate]=-13;
			while (nMotorEncoder[motorArmRotate]>-1100){
				wait1Msec(1);
			}
			motor[motorArmRotate]=0;
			wait10Msec(AWT);
		}
	}

}

//********************************************************************
//Functions
//********************************************************************
void Stopbot(){
	motor[motorF]=0;
	motor[motorL]=0;
	motor[motorR]=0;
	motor[motorB]=0;
	wait10Msec(WWT);
}

void Forward(){
	motor[motorF]=0;
	motor[motorL]=MP;
	motor[motorR]=-MP;
	motor[motorB]=0;
}

void Back(){
	motor[motorF]=0;
	motor[motorL]=-MP;
	motor[motorR]=MP;
	motor[motorB]=0;
}

void Left(){
	motor[motorF]=-MP;
	motor[motorL]=0;
	motor[motorR]=0;
	motor[motorB]=MP;
}

void Right(){
	motor[motorF]=MP;
	motor[motorL]=0;
	motor[motorR]=0;
	motor[motorB]=-MP;
}

void TLeft(){
	motor[motorF]=-MP;
	motor[motorL]=MP;
	motor[motorR]=MP;
	motor[motorB]=-MP;
}

void TRight(){
	motor[motorF]=MP;
	motor[motorL]=-MP;
	motor[motorR]=-MP;
	motor[motorB]=MP;
}


//This function rotate servoIR and find the ir beacon, and returns
//degrees of turning from the front direction of robot, negative value
//indicates IR beacon on the right, positive on the left

int Scan()
{
	//initial scan to decide where the beacon is
	char turn_direction='N';                //turn direction: R-right; L-left; N- null
	int ir_mid_position=110;
	int ir_start_position=60;
	int ir_stop_position=180;
	int ir_max_position=110;                //servo position/angle where IR reading reaches maximum
	int ir_reading_maxDC=0;
	int ir_reading_maxAC=0;
	int ir_change_rate=5;
	int _dirDC = 0;
	int _dirAC = 0;
	int dcS1, dcS2, dcS3, dcS4, dcS5 = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;
	// the default DSP mode is 1200 Hz.
	//      tHTIRS2DSPMode _mode = DSP_1200;

	servoChangeRate[servoIR]=ir_change_rate;
	servo[servoIR]=ir_mid_position;
	wait1Msec(1000);
	// Read the current non modulated signal direction
	_dirDC = HTIRS2readDCDir(IRFind);
	_dirAC=HTIRS2readACDir(IRFind);
	nxtDisplayCenteredTextLine(0,"%d",_dirDC);
	nxtDisplayCenteredTextLine(1,"%d",_dirAC);
	wait1Msec(10);
		//turn left or right depending on IR reading, until direction reaches 5
		// set "turn_direction" glas

		//if servoIR middle zone points to IR beacon, turn left to it is on zone 4
	if (_dirAC==5){
		servo[servoIR]=servo[servoIR]-30;
		turn_direction='R';
		nxtDisplayCenteredTextLine(3,"%d", ServoValue[servoIR]);
		wait1Msec(1000);
	}

	// now that ir beacon should be on the right or left side of the robot;
	while ((_dirAC>5) &&(ServoValue[servoIR]<ir_stop_position)){
		turn_direction='R';
		servo[servoIR]=servo[servoIR]+10;
		nxtDisplayCenteredTextLine(4,"turning Right");
		wait1Msec(500);
		_dirAC = HTIRS2readACDir(IRFind);
	}
	while ((_dirAC<5) &&(ServoValue[servoIR]>ir_start_position)){
		turn_direction='L';
		servo[servoIR]=servo[servoIR]-10;
		nxtDisplayCenteredTextLine(5,"turning left");
		wait1Msec(500);
		_dirAC = HTIRS2readACDir(IRFind);
	}

		//now that _dirDC=5,continue turning on same direction until maxium
		//reading in zone 5.
		// Read the individual signal strengths of the internal sensors
		// Do this for both unmodulated (DC) and modulated signals (AC)
	HTIRS2readAllDCStrength(IRFind, dcS1, dcS2, dcS3, dcS4, dcS5);
	HTIRS2readAllACStrength(IRFind, acS1, acS2, acS3, acS4, acS5 );
	wait1Msec(1);

		// set temporary ir maximium position
	ir_max_position=ServoValue[servoIR];
	ir_reading_maxDC=dcS3;
	ir_reading_maxAC=acS3;

		//continue turning left until mid zone reading max
	if (turn_direction=='L'){

		while (dcS3>=ir_reading_maxDC || acS3>=ir_reading_maxAC){

		//assign current ir reading to ir_reading_maxDC and ir_reading_maxAC
		ir_reading_maxDC=dcS3;
		ir_reading_maxAC=acS3;

		//continue turning left if not reading maximum ir reading
		servo[servoIR]=servo[servoIR]-5;
		ir_max_position=ServoValue[servoIR];
		wait1Msec(200);
		turn_direction='L';

		//read servoIR values
		HTIRS2readAllDCStrength(IRFind, dcS1, dcS2, dcS3, dcS4, dcS5);
		HTIRS2readAllACStrength(IRFind, acS1, acS2, acS3, acS4, acS5 );
		wait1Msec(10);
		}
	}
	//continue turning left until mid zone reading max
	else if (turn_direction=='R'){

		while (dcS3>=ir_reading_maxDC || acS3>=ir_reading_maxAC){

		//assign current ir reading to ir_reading_maxDC and ir_reading_maxAC
		ir_reading_maxDC=dcS3;
		ir_reading_maxAC=acS3;

		//continue turning left if not reading maximum ir reading
		servo[servoIR]=servo[servoIR]+5;
		ir_max_position=ServoValue[servoIR];
		turn_direction='R';
		wait1Msec(200);
		//read servoIR values
		HTIRS2readAllDCStrength(IRFind, dcS1, dcS2, dcS3, dcS4, dcS5);
		HTIRS2readAllACStrength(IRFind, acS1, acS2, acS3, acS4, acS5 );
		wait1Msec(10);
		}
	}
	//default turn direction is null
	else {
		turn_direction='N';
	}
	return ((ir_max_position-ir_mid_position)*180)/255; //return degrees robot need to turn toward IR beacon
}
