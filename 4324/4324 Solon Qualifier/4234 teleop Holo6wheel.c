#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorL,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorR,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorB,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorF,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorArmRotate, tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     motorArmUpDown, tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    servoClaw,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servoCGrip,           tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servoWall,            tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma debuggerWindows("joystickSimple")
#include "JoystickDriver.c"

void MoveBot();											//Move the robot
void MoveManipulator(int JoyT);			//Move the arm, claw, and walls. Input: the JoyDelay Variable
int CalcJoy(int Wheel);							//Calculate the movement of the robot. 1:MotorL, 2:MotorR, 3:MotorB, 4:MotorF
int CalcJoyrotate();								//Calculate the rotation of the robot.
int CalcJoyratio(int Wheel);				//Determine motor movement speeds based on motor speed ratios. 1:return values for motorFL, 2:motorFR, 3:motorBL, 4:motorBR
void DebugMode();										//Mode to debug the robot

//CONSTANTS: Change these to modify stuff like motor speed, arm speed, etc.
const int DZ=10;										//The Deadzone value. Determines values that are in the deadzone		0-20
const int ArmSpeedUp=5;							//Affects the factor by which the Arm Speeds up											1-10
const int SCRate=2;									//The rate of change on the servos																	1-10
const int SCSpeedUp=5;							//Affects the factor by which the Claw Speeds up										1-10
const int MaxMotorPower=50;					//Affects the maximum speed of the Drive motors.										1-100



//Test each of the motors individually
//Joy1_y1=FL motor, Joy1_y_2=FR motor, 5 & 7=BL motor, 6 & 8=BR motor
void DebugMode(){
	wait10Msec(100);
	int DModeOn=true;											//This is true while Debug mode on
	while (DModeOn==true){
		getJoystickSettings(joystick);
		if (joystick.joy1_y1>DZ){
			motor[motorL]=100;
		}
		else if (joystick.joy1_y1<-DZ){
			motor[motorL]=-100;
		}
		else {
			motor[motorL]=0;
		}
		if (joystick.joy1_y2>DZ){
			motor[motorR]=100;
		}
		else if (joystick.joy1_y2<-DZ){
			motor[motorR]=-100;
		}
		else {
			motor[motorR]=0;
		}
		if (joy1Btn(7)==true){
			motor[motorB]=100;
		}
		else if (joy1Btn(5)==true){
			motor[motorB]=-100;
		}
		else {
			motor[motorB]=0;
		}
		if (joy1Btn(8)==true){
			motor[motorF]=100;
		}
		else if (joy1Btn(6)==true){
			motor[motorF]=-100;
		}
		else {
			motor[motorF]=0;
		}
		if (joy1Btn(4)==true){
			motor[motorArmUpDown]=-20;
		}
		else if (joy1Btn(2)==true){
			motor[motorArmUpDown]=20;
		}
		else{
			motor[motorArmUpDown]=0;
		}
		if (joy1Btn(1)==true){
			motor[motorArmRotate]=-20;
		}
		else if (joy1Btn(3)==true){
			motor[motorArmRotate]=20;
		}
		else{
			motor[motorArmRotate]=0;
		}
		if (joy1Btn(10)&joy1Btn(9)){
			DModeOn=false;
		}
		wait10Msec(1);
	}
	wait10Msec(100);
}

//Determines Motor powers needed to cause robot to rotate
//the reason of using substraction is to make the motor turn according to the joystick
//Returns values base on input
int CalcJoyrotate(){
	if (joystick.joy1_x2>DZ||joystick.joy1_x2<-DZ){
		return -joystick.joy1_x2;		//Return appropriate motor values
	}
	else{
		return 0;
	}
}

//Determines motor powers needed to cause the robot to move
//Return values based on motor
//the controller registers positive values of y1/y2 as joystick points down
int CalcJoy(int Wheel){
	if ((joystick.joy1_y1>DZ||joystick.joy1_y1<-DZ)&Wheel<=2){						//Checks to see if joystick is in Deadzone
		if (Wheel==1){
			return joystick.joy1_y1;		//return appropriate motor values
		}
		else if (Wheel==2){
			return -joystick.joy1_y1;
		}
	}
	else if ((joystick.joy1_x1>DZ||joystick.joy1_x1<-DZ)&(joystick.joy1_y1>-40||joystick.joy1_y1<40)){
		if (Wheel==3){
			return -joystick.joy1_x1;
		}
		else if (Wheel==4){
			return joystick.joy1_x1;
		}
	}
	else{
		return 0;
	}
}

//becaue joysticks values can go above 100 (-128 to 127), Fmove, Rmove, Lmove, and Bmove can be above 100
//Motor can't handle values above 100 and the motor power must be accodingly adjusted
//This part reduces those variables to below 100 and keeps them in the same ratios to eachother
int CalcJoyratio(int Wheel){
	int Lmove=CalcJoy(1)+CalcJoyrotate();
	int Rmove=CalcJoy(2)+CalcJoyrotate();
	int Bmove=CalcJoy(3)+CalcJoyrotate();
	int Fmove=CalcJoy(4)+CalcJoyrotate();
	if (abs(Lmove)>MaxMotorPower){
		Lmove=Lmove*(MaxMotorPower/abs(Lmove));									//If Lmove is above 100, reduce it to 100
		Rmove=Rmove*(MaxMotorPower/abs(Lmove));									//Reduce the speed of the remaining motors based on the ratios of motor speeds
		Bmove=Bmove*(MaxMotorPower/abs(Lmove));
		Fmove=Fmove*(MaxMotorPower/abs(Lmove));
	}
	if (abs(Rmove)>MaxMotorPower){
		Lmove=Lmove*(MaxMotorPower/abs(Rmove));									//Same procedure, except with R
		Rmove=Rmove*(MaxMotorPower/abs(Rmove));
		Bmove=Bmove*(MaxMotorPower/abs(Rmove));
		Fmove=Fmove*(MaxMotorPower/abs(Rmove));
	}
	if (abs(Bmove)>MaxMotorPower){
		Lmove=Lmove*(MaxMotorPower/abs(Bmove));									//Same procedure, except with B
		Rmove=Rmove*(MaxMotorPower/abs(Bmove));
		Bmove=Bmove*(MaxMotorPower/abs(Bmove));
		Fmove=Fmove*(MaxMotorPower/abs(Bmove));
	}
	if (abs(Fmove)>MaxMotorPower){
		Lmove=Lmove*(MaxMotorPower/abs(Fmove));									//Same procedure, except with F
		Rmove=Rmove*(MaxMotorPower/abs(Fmove));
		Bmove=Bmove*(MaxMotorPower/abs(Fmove));
		Fmove=Fmove*(MaxMotorPower/abs(Fmove));
	}
	Lmove=(Lmove);																//Turn motor speeds into integers
	Rmove=(Rmove);
	Bmove=(Bmove);
	Fmove=(Fmove);
	if (Wheel==1){
		return Lmove;
	}
	else if (Wheel==2){
		return Rmove;
	}
	else if (Wheel==3){
		return Bmove;
	}
	else{
		return Fmove;
	}
}

//apply the functions for determining motor power values
//assign motor powers to values determined by functions
void MoveBot(){
	if ((joy1Btn(7)==true)||(joy1Btn(8)==true)||(joy1Btn(1)==true)||(joy1Btn(2)==true)||(joy1Btn(3)==true)||(joy1Btn(4)==true)){
		motor[motorL]=CalcJoyratio(1)*2;		//Assign motors to appropriate motor speeds
		motor[motorR]=CalcJoyratio(2)*2;
		motor[motorB]=CalcJoyratio(3)*2;
		motor[motorF]=CalcJoyratio(4)*2;
	}
	else {
		motor[motorL]=CalcJoyratio(1);		//Assign motors to appropriate motor speeds
		motor[motorR]=CalcJoyratio(2);
		motor[motorB]=CalcJoyratio(3);
		motor[motorF]=CalcJoyratio(4);
	}
}

//Move the arm and claw and walls of the robot based on inputs from second controller
void MoveManipulator(int JoyT){
	//Everything Arm Related
	int Armspeed=1;																		//Speed up the Arm is button is pressed
	if ((joy2Btn(11)==true)||(joy2Btn(12)==true)){
		Armspeed=ArmSpeedUp;
	}
	if ((joystick.joy2_y1>DZ) || (joystick.joy2_y1<-DZ)){													//Move Arm motor 1
		motor[motorArmUpDown]= ((-joystick.joy2_y1*20*Armspeed)/128);
	}
	else {
		motor[motorArmUpDown]=0;
	}
	if (((joystick.joy2_x2>DZ) || (joystick.joy2_x2<-DZ))&(JoyT>5||Armspeed>1)){	//Move Arm motor 2
		if (Armspeed==1){
			motor[motorArmRotate]= ((joystick.joy2_x2*15)/128);
		}
		else{
			motor[motorArmRotate]= ((joystick.joy2_x2*13)/128);
		}
	}
	else {
		motor[motorArmRotate]=0;
	}

	//Everything Claw Related
	int CurrentClaw=ServoValue[servoClaw];						//Update the current Claw value
	int CurrentCGrip=ServoValue[servoCGrip];					//Update the current CGrip value
	if (joy2Btn(1)==true){														//Speed up the Claw if Button is pressed
		servoChangeRate[servoClaw]=SCRate*SCSpeedUp;
		servoChangeRate[servoCGrip]=SCRate*SCSpeedUp;
	}
	else{
		servoChangeRate[servoClaw]=SCRate;
		servoChangeRate[servoCGrip]=SCRate*SCSpeedUp;
	}
	if (joy2Btn(8)==true){													//Move the claw
		servo[servoClaw]=240;
	}
	else if (joy2Btn(6)==true){
		servo[servoClaw]=15;
	}
	else{
		servo[servoClaw]=CurrentClaw;
	}
	if (joy2Btn(5)==true){													//Move the CGrip
		servo[servoCGrip]=255;
	}
	else if (joy2Btn(7)==true){
		servo[servoCGrip]=0;
	}

	//Everything Wall Related. Walls are not present in this version of the robot
	int CurrentWall=ServoValue[servoWall];
	if (joy1Btn(5)==true){													//Move the Wall
		servo[servoWall]=240;
	}
	else if (joy1Btn(7)==true){
		servo[servoWall]=15;
	}
}

task main()
{
	servo[servoWall]=240;
	int JoyT=15;											//Joystick Timer. Dictates when the Arm can move and when it doesn't
	while(1==1){
		getJoystickSettings(joystick);	//Reset joystick values
		MoveManipulator(JoyT);							//Move Robot arm
		if (joy1Btn(10)&joy1Btn(9)){
			DebugMode();
		}
		MoveBot();											//Move robot
		wait10Msec(1);
		if (JoyT<=0){
			JoyT=15;
		}
		JoyT-=1;
	}
}
